import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

public class TicTacToe {

    public static void main(String[] args) {
        State state = new State();
        Player player = Player.X;

        int moves = 10;
        while (moves-- > 0) {
            Agent agent = new Agent();
            state = agent.move(state, player);
            if (Objects.isNull(state)) {
                break;
            }
            player = player.next();
            System.out.println(state);
        }
    }

    public static class Agent {

        public Agent() {

        }

        public State move(State state, Player player) {
            List<State> nextStates = state.from(player);
            State optimalState = null;
            int maxValue = Integer.MIN_VALUE;
            for (State nextState : nextStates) {
                int value = maxValue(nextState, player);
                if (value > maxValue) {
                    maxValue = value;
                    optimalState = nextState;
                }
            }
            return optimalState;
        }

        private int maxValue(State state, Player maximisingPlayer) {
            /* Null checks */
            if (Objects.isNull(state)) {
                throw new IllegalArgumentException("State cannot be null");
            }
            if (Objects.isNull(maximisingPlayer)) {
                throw new IllegalArgumentException("Maximising player cannot be null");
            }

            /* We always evaluate the state generated by the maximising player */
            if (state.isTerminal()) {
                return state.evaluate(maximisingPlayer).getValue();
            }

            /*
            Since the maximising player will be playing optimally, they will try to maximise the
            score generated by the minimising player's moves. We only care about the maximum of these moves.
             */
            int val = Integer.MIN_VALUE;
            Player minimisingPlayer = maximisingPlayer.next();
            List<State> nextStates = state.from(minimisingPlayer);
            for (State nextState : nextStates) {
                val = Integer.max(val, minValue(nextState, minimisingPlayer));
            }
            return val;
        }

        private int minValue(State state, Player minimisingPlayer) {
            /* Null checks */
            if (Objects.isNull(state)) {
                throw new IllegalArgumentException("State cannot be null");
            }
            if (Objects.isNull(minimisingPlayer)) {
                throw new IllegalArgumentException("Minimising player cannot be null");
            }

            /* We always evaluate the state generated by the maximising player */
            Player maximisingPlayer = minimisingPlayer.next();
            if (state.isTerminal()) {
                return state.evaluate(maximisingPlayer).getValue();
            }

            /*
            Since the minimising player will be playing optimally, they will try to minimise the
            maximising player's score.
             */
            List<State> nextStates = state.from(maximisingPlayer);
            int val = Integer.MAX_VALUE;
            for (State nextState : nextStates) {
                val = Integer.min(val, maxValue(nextState, maximisingPlayer));
            }
            return val;
        }
    }

    public enum Player {

        X,
        O;

        public Player next() {
            return Arrays.stream(values())
                    .filter(player -> player != this)
                    .collect(Collectors.toList())
                    .get(0);
        }
    }

    public enum Result {

        LOSS(0),
        NONE(1),
        TIE(2),
        WIN(3);

        private final int value;

        Result(int value) {
            this.value = value;
        }

        public int getValue() {
            return value;
        }
    }

    public static class State {

        private static final int DIM = 3;

        private static final int WINNER_COUNT = 3;

        private final Player[][] board;

        public State() {
            this.board = new Player[DIM][DIM];
        }

        private static State from(State state) {
            State newState = new State();
            for (int i = 0; i < DIM; i++) {
                for (int j = 0; j < DIM; j++) {
                    newState.board[i][j] = state.board[i][j];
                }
            }
            return newState;
        }

        public List<State> from(Player player) {
            if (isTerminal()) {
                return Collections.emptyList();
            }
            List<State> nextStates = new ArrayList<>();
            for (int i = 0; i < DIM; i++) {
                for (int j = 0; j < DIM; j++) {
                    if (Objects.isNull(board[i][j])) {
                        nextStates.add(from(player, i, j));
                    }
                }
            }
            return nextStates;
        }

        private State from(Player player, int i, int j) {
            if (i < 0 || j < 0 || i >= DIM || j >= DIM) {
                throw new IllegalArgumentException(String.format("Position (%d, %d) out of bounds of the board", i, j));
            }
            if (board[i][j] != null) {
                throw new IllegalArgumentException(String.format("Position (%d, %d) already occupied", i, j));
            }
            State newState = from(this);
            newState.board[i][j] = player;
            return newState;
        }

        public boolean isTerminal() {
            Optional<Player> winner = Arrays.stream(Player.values())
                    .map(this::checkWinner)
                    .filter(Objects::nonNull)
                    .findFirst();
            if (winner.isPresent()) {
                return true;
            }
            return checkTie();
        }

        public Result evaluate(Player currentPlayer) {
            Player winner = checkWinner(currentPlayer);
            if (winner == currentPlayer) {
                return Result.WIN;
            }
            else if (Objects.nonNull(winner)) {
                return Result.LOSS;
            }
            else if (checkTie()) {
                return Result.TIE;
            }
            return Result.NONE;
        }

        /**
         * Assuming that the winner check has already been done, if all the cells are full,
         * the game has been drawn
         */
        private boolean checkTie() {
            int count = 0;
            for (int i = 0; i < DIM; i++) {
                for (int j = 0; j < DIM; j++) {
                    if (Objects.nonNull(board[i][j])) {
                        count++;
                    }
                }
            }
            return count == DIM * DIM;
        }

        private Player checkWinner(Player player) {
            int i = 0;
            int j = 0;
            int count = 0;

            /* Check SE diagonal diagonal */
            while (i < DIM && j < DIM) {
                if (board[i][j] == player) {
                    count++;
                }
                i++;
                j++;
            }
            if (count == WINNER_COUNT) {
                return player;
            }

            /* Check SW diagonal */
            i = 0;
            j = DIM-1;
            count = 0;
            while (i < DIM && j >= 0) {
                if (board[i][j] == player) {
                    count++;
                }
                i++;
                j--;
            }
            if (count == WINNER_COUNT) {
                return player;
            }

            /* Check S */
            for (j = 0; j < DIM; j++) {
                count = 0;
                for (i = 0; i < DIM; i++) {
                    if (board[i][j] == player) {
                        count++;
                    }
                }
                if (count == WINNER_COUNT) {
                    return player;
                }
            }

            /* Check E */
            for (i = 0; i < DIM; i++) {
                count = 0;
                for (j = 0; j < DIM; j++) {
                    if (board[i][j] == player) {
                        count++;
                    }
                }
                if (count == WINNER_COUNT) {
                    return player;
                }
            }

            return null;
        }

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < DIM; i++) {
                StringBuilder rowBuilder = new StringBuilder();
                for (int j = 0; j < DIM; j++) {
                    rowBuilder.append(board[i][j] != null ? board[i][j] : "_");
                }
                rowBuilder.append("\n");
                builder.append(rowBuilder);
            }
            return builder.toString();
        }
    }
}
